<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>Real-time Satellite Position</title>
    <script src="https://d3js.org/d3.v7.min.js"></script>
    <script src="https://cdn.jsdelivr.net/npm/satellite.js@2.0.0/dist/satellite.min.js"></script>
    <style>
        svg {
            border: 3px solid black;
           
        }
        #satelliteInfo {
            position: absolute;
            background-color: rgba(255, 255, 255, 0.8);
            border: 1px solid #333;
            padding: 10px;
            font-size: 14px;
            display: none;
            pointer-events: none;
            z-index: 9999;
            max-width: 300px;
        }
    </style>
</head>
<body>
    
    <svg width="2000" height="1200" viewBox="-100 0 1600 1200" xmlns="http://www.w3.org/2000/svg"></svg>
    <div id="satelliteInfo"></div> <!-- 卫星信息显示框 -->

    <script>
        const svg = d3.select("svg").append('g').attr("transform", "translate(790,800)");
        const width = +svg.attr("width");
        const height = +svg.attr("height");

        // 使用 Mercator 投影
        const projection = d3.geoMercator()
            .scale(250)
            .translate([width / 2, height / 1.5]);

        const path = d3.geoPath().projection(projection);

        // 请求TLE数据的函数，使用 Celestrak API 获取卫星TLE
        function getTLEData() {
            //const url = 'https://www.celestrak.com/NORAD/elements/stations.txt'; // 获取卫星TLE数据
            const url = 'satellite_BEIDOU.txt';
            return fetch(url)
                .then(response => response.text())
                .then(text => {
                    const lines = text.trim().split('\n');
                    const satellites = [];
                    for (let i = 0; i < lines.length; i += 3) {
                        const name = lines[i].trim();
                        const tleLine1 = lines[i + 1].trim();
                        const tleLine2 = lines[i + 2].trim();

                        if (name && tleLine1 && tleLine2) {
                            satellites.push({
                                name: name,
                                tle: [tleLine1, tleLine2],
                                trajectory: []  // 初始化轨迹数组
                            });
                        }
                    }
                    
                    return satellites;

                })
                .catch(error => {
                    console.error("Error fetching TLE data:", error);
                    return [];
                });
        }
        function normalizeLongitude(longitude) {
            while (longitude > Math.PI) {
                longitude -= 2 * Math.PI; // 迭代减去 2π，直到其在 -π 到 +π 范围内
            }
            while (longitude < -Math.PI) {
                longitude += 2 * Math.PI; // 迭代加上 2π，直到其在 -π 到 +π 范围内
            }
            return longitude;
        }
        // 请求卫星实时位置的模拟函数
        function getSatellitePosition(tle) {
            const satrec = satellite.twoline2satrec(tle[0], tle[1]);
            const now = new Date();
            const positionAndVelocity = satellite.propagate(satrec, now);
            const position = positionAndVelocity.position;
            const gmst = satellite.gstime(now);
            const positionGd = satellite.eciToGeodetic(position, gmst);

            // 将弧度约束在有效范围内
            //const constrainedLongitude = positionGd.longitude > Math.PI ? positionGd.longitude % Math.PI : (positionGd.longitude < -Math.PI ? -((-positionGd.longitude)%Math.PI) : positionGd.longitude);
            const constrainedLongitude = normalizeLongitude(positionGd.longitude);
            const constrainedLatitude = positionGd.latitude > Math.PI / 2 ? Math.PI / 2 : (positionGd.latitude < -Math.PI / 2 ? -Math.PI / 2 : positionGd.latitude);

            if (positionGd) {
                const longitude = satellite.degreesLong(constrainedLongitude);
                const latitude = satellite.degreesLat(constrainedLatitude);
                return { lon: longitude, lat: latitude ,height : positionGd.height};
            } else {
                return { lon: 0, lat: 0,height : 0};
            }
        }

        // 卫星信息框
        const infoBox = d3.select("#satelliteInfo");

        // 显示卫星信息
        function showSatelliteInfo(position, event) {
            const mouseX = event.pageX;
            const mouseY = event.pageY;

            // 显示卫星信息框，位置跟随鼠标
            infoBox.style("display", "block")
                .style("top", (mouseY + 10) + "px")
                .style("left", (mouseX + 10) + "px")
                .html(
                    `<strong>卫星名称:</strong> ${position.name}<br>
                    <strong>经度:</strong> ${position.lon.toFixed(2)}<br>
                    <strong>纬度:</strong> ${position.lat.toFixed(2)}`
                );
        }

        // 隐藏卫星信息框
        function hideSatelliteInfo() {
            infoBox.style("display", "none");
        }

        Promise.all([
            d3.json('world.json'),  // 获取世界地图数据
            getTLEData()  // 获取卫星TLE数据
        ]).then(([geodata, satellites]) => {
            if (geodata.features) {
                
                // 绘制世界地图
                svg.selectAll("path")
                    .data(geodata.features)
                    .enter()
                    .append("path")
                    .attr("class", "country")
                    .attr("d", path)
                    .attr('fill', 'lightgray')
                    .attr('stroke','#333')
                    .on("click", function(event, d) {
                        let countryName = d.properties.name;
                        svg.selectAll(".country-name").remove();

                        let [x, y] = d3.pointer(event);

                        svg.append("text")
                            .attr("class", "country-name")
                            .attr("x", x + 10)
                            .attr("y", y - 10)
                            .attr("font-size", "12px")
                            .attr("fill", "black")
                            .text(countryName);
                    })
                    .attr('z-index', -99);

                  // 绘制经度网格并添加经度信息
                  for (let lon = -180; lon <= 180; lon += 10) {
                    // 绘制线条
                    let line = svg.append("line")
                        .attr("x1", projection([lon, -80])[0])
                        .attr("y1", projection([lon, -80])[1])
                        .attr("x2", projection([lon, 90])[0])
                        .attr("y2", projection([lon, 90])[1])
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("stroke-dasharray", "2,2")
                        .attr('z-index', -100);

                    // 在网格线一端显示经度信息
                    svg.append("text")
                        .attr("x", projection([lon, 85])[0] + 5)  // 文字位置（右侧偏移）
                        .attr("y", projection([lon, 85])[1])
                        .attr("font-size", "10px")
                        .attr("fill", "black")
                        .text(lon);  // 显示经度
                        
                }

                // 绘制纬度网格并添加纬度信息
                for (let lat = -80; lat <= 90; lat += 10) {
                    // 绘制线条
                    let line = svg.append("line")
                        .attr("x1", projection([-180, lat])[0])
                        .attr("y1", projection([-180, lat])[1])
                        .attr("x2", projection([180, lat])[0])
                        .attr("y2", projection([180, lat])[1])
                        .attr("stroke", "lightgray")
                        .attr("stroke-width", 0.5)
                        .attr("stroke-dasharray", "2,2")
                        .attr('z-index', -100);

                    // 在网格线一端显示纬度信息
                    svg.append("text")
                        .attr("x", projection([180, lat])[0] + 5)  // 文字位置（右侧偏移）
                        .attr("y", projection([180, lat])[1])
                        .attr("font-size", "10px")
                        .attr("fill", "black")
                        .text(lat);  // 显示纬度
                }

                // 为每颗卫星绘制轨迹和实时位置
                const colors = ["yellow", "red", "blue", "green", "purple", "orange", "pink", "cyan", "brown", "gray"];
                const satelliteDots = [];
                satellites.forEach((satelliteData, index) => {
                    const satelliteDot = svg.append("circle")
                        .attr("r", 12+index*2)
                        .attr("fill", colors[index%10])
                        .attr("cx", projection([0, 0])[0]) // 初始化位置
                        .attr("cy", projection([0, 0])[1])
                        .style("cursor", "pointer")
                        .datum({ lon: 0, lat: 0, name: satelliteData.name })
                        .on("mouseover", function(event) {
                            const position = d3.select(this).datum();
                            showSatelliteInfo(position, event);
                        })
                        .on("mouseout", hideSatelliteInfo)
                        .attr("opacity", 0.7);  // 设置透明度
                    // 初始化轨迹路径
                    satelliteData.trajectoryPath = svg.append("path")
                        .attr("fill", "none")
                        .attr("stroke", "blue")
                        .attr("stroke-width", 1);
                    
                    satelliteDots.push(satelliteDot);
                    
                });
                
                const lastlon = [];
                // 动画：根据卫星实时位置更新
                // 创建clipPath元素
                const clipPath = svg.append("defs")
                    .append("clipPath")
                    .attr("id", "clip-circle")
                    .append("circle")
                    .attr("cx", width / 2)  // 圆心位置
                    .attr("cy", height / 2)
                    .attr("r", Math.min(width, height) / 2);  // 半径设置为最小边的一半，确保在svg内显示

                function updateSatellitePosition() {
                    satellites.forEach((satelliteData, index) => {
                        
                        const position = getSatellitePosition(satelliteData.tle);


                        // 更新卫星的位置
                        satelliteDots[index].datum({ lon: position.lon, lat: position.lat, name: satelliteData.name })
                            .attr("cx", projection([position.lon, position.lat])[0])
                            .attr("cy", projection([position.lon, position.lat])[1]);
                        let altitude = position.height;
                        // 计算轨道半径：根据高度设置卫星圆形的半径，假设轨道高度越低，圆形半径越大
                        const earthRadius = 6371;  // 地球的半径，单位是 km
                        
                        // 计算视距半径
                        const viewRadius = Math.sqrt(2 * earthRadius * altitude + Math.pow(altitude, 2));
                        // 缩放视距半径以适应画布（单位：像素）
                        const width = 1600;
                        const height = 1200;
                        const canvasViewRadius = viewRadius * Math.sqrt(width*height/(4*Math.PI*earthRadius*earthRadius));
                        satelliteDots[index].attr("r", canvasViewRadius);
                        

                        const minLon = position.lon - viewRadius / earthRadius * (180 / Math.PI);
                        const maxLon = position.lon + viewRadius / earthRadius * (180 / Math.PI);

                         // 手动计算经纬度转换为像素坐标
                        function lonLatToPixel(lon, lat) {
                            const x = (lon + 180) * (width / 360);  // 将经度转换为画布上的 x 坐标
                            const y = (90 - lat) * (height / 180);  // 将纬度转换为画布上的 y 坐标
                            return [x, y];
                        }

                        // 检查是否跨越 180° 经线，并在另一边绘制圆
                        if (minLon < -180) {
                            // 计算另一个圆，跨越 -180° 经线
                            const wrappedLon = position.lon + 360;  // 将经度加 360°，让其处于 [0, 180] 范围
                            const [px, py] = lonLatToPixel(wrappedLon, position.lat);  // 计算像素坐标
                            console.log(px,py);
                            const viewCircle = svg.append("circle")
                                .attr("cx", px)  // 使用计算后的像素坐标
                                .attr("cy", py)
                                .attr("clip-path", "url(#clip-circle)")  // 应用裁剪路径
                                .attr("r", canvasViewRadius)  // 使用计算后的视距半径
                                .attr("fill", "rgba(0, 255, 0, 0.2)")  // 半透明绿色
                                .attr("stroke", "green")
                                .attr("stroke-width", 1)
                                .transition()  // 添加过渡效果
                                .duration(1800)  // 1800ms 后消失
                                .attr("opacity", 0)  // 透明度渐变到 0
                                .remove();  // 完全消失后删除元素
                        }

                        if (maxLon > 180) {
                            // 计算另一个圆，跨越 180° 经线
                            const wrappedLon = position.lon - 360;  // 将经度减 360°，让其处于 [-180, 0] 范围
                            const [px, py] = lonLatToPixel(wrappedLon, position.lat);  // 计算像素坐标
                            console.log(px,py);
                            const viewCircle = svg.append("circle")
                                .attr("cx", px)  // 使用计算后的像素坐标
                                .attr("cy", py)
                                .attr("clip-path", "url(#clip-circle)")  // 应用裁剪路径
                                .attr("r", canvasViewRadius)  // 使用计算后的视距半径
                                .attr("fill", "rgba(0, 255, 0, 0.2)")  // 半透明绿色
                                .attr("stroke", "green")
                                .attr("stroke-width", 1)
                                .transition()  // 添加过渡效果
                                .duration(1800)  // 1800ms 后消失
                                .attr("opacity", 0)  // 透明度渐变到 0
                                .remove();  // 完全消失后删除元素
                        }

                        // 更新轨迹
                        if(lastlon[index]<position.lon)
                        {
                            satelliteData.trajectory.push([position.lon, position.lat]);
                            satelliteData.trajectoryPath
                                .attr("d", d3.line()(satelliteData.trajectory.map(d => projection(d))));
                        }
                        else
                        {
                            satelliteData.trajectory = [];
                            satelliteData.trajectoryPath
                            .attr("d", d3.line()(satelliteData.trajectory.map(d => projection(d))));
                        }
                        lastlon[index] = position.lon;
                    });

                    setTimeout(updateSatellitePosition, 1500);  
                }

                updateSatellitePosition(); // 开始实时更新卫星位置
                
                svg.on("click", hideSatelliteInfo);

            } else {
                console.error("Data format is incorrect");
            }
        }).catch(error => {
            console.error("Error loading the JSON data: ", error);
        });
    </script>
</body>
</html>
