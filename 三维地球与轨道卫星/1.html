<!DOCTYPE html>
<html lang="en">
<head>
  <meta charset="UTF-8">
  <meta name="viewport" content="width=device-width, initial-scale=1.0">
  <title>3D地球与卫星轨道</title>
  <style>
    body { margin: 0; overflow: hidden; }
    canvas { display: block; }
  </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script>
  // 场景设置
  const scene = new THREE.Scene();
  const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
  const renderer = new THREE.WebGLRenderer();
  renderer.setSize(window.innerWidth, window.innerHeight);
  document.body.appendChild(renderer.domElement);

  // 创建地球球体
  const earthGeometry = new THREE.SphereGeometry(5, 64, 64); // 更高的分段数使球体更加平滑
  const textureLoader = new THREE.TextureLoader();
  const earthTexture = textureLoader.load('https://api.allorigins.win/raw?url=https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg');
  const earthMaterial = new THREE.MeshStandardMaterial({
    map: earthTexture,
    emissive: new THREE.Color(0xeeeeee), // 发光效果
    emissiveIntensity: 0.1
  });
  const earth = new THREE.Mesh(earthGeometry, earthMaterial);
  scene.add(earth);

  // 添加点光源实现地球的光晕效果
  const pointLight = new THREE.PointLight(0xffffff, 1, 100);
  pointLight.position.set(10, 10, 10);
  scene.add(pointLight);

  // 添加环境光源提供柔和的光照
  const ambientLight = new THREE.AmbientLight(0x404040); // 柔和的白色光源
  scene.add(ambientLight);

  // 设置摄像机位置
  camera.position.z = 20;

  // 添加简单的星空背景
  const starsGeometry = new THREE.SphereGeometry(50, 64, 64);
  const starsMaterial = new THREE.MeshBasicMaterial({
    color: 0x000000,
    side: THREE.BackSide,
    map: textureLoader.load('https://api.allorigins.win/raw?url=https://www.solarsystemscope.com/textures/download/2k_stars.jpg')
  });
  const stars = new THREE.Mesh(starsGeometry, starsMaterial);
  scene.add(stars);

  // 初始化 OrbitControls 以便可以用鼠标拖动
  const controls = new THREE.OrbitControls(camera, renderer.domElement);

  // 封装创建轨道和卫星的函数，添加初始角度参数
  function createOrbitAndSatellite(orbitRadius, orbitInclineAnglex, orbitInclineAngley, initialSatelliteAngle) {
    // 创建卫星轨道
    const orbitGeometry = new THREE.RingGeometry(orbitRadius, orbitRadius + 0.2, 64); // 创建轨道环
    const orbitMaterial = new THREE.MeshBasicMaterial({ color: 0x888888, side: THREE.DoubleSide });
    const orbit = new THREE.Mesh(orbitGeometry, orbitMaterial);

    // 设置轨道的倾斜角度
    orbit.rotation.x = orbitInclineAnglex; // 轨道绕x轴倾斜
    orbit.rotation.y = orbitInclineAngley; // 轨道绕y轴倾斜
    scene.add(orbit);

    // 创建卫星
    const satelliteGeometry = new THREE.SphereGeometry(0.5, 16, 16); // 卫星的小球
    const satelliteMaterial = new THREE.MeshStandardMaterial({ color: 0xff0000 }); // 卫星的材质
    const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
    scene.add(satellite);

    // 初始化卫星的角度
    let satelliteAngle = initialSatelliteAngle;

    // 返回轨道、卫星和卫星角度的对象
    return { orbit, satellite, satelliteAngle };
  }

  // 创建第一组轨道和卫星
  const { orbit: orbit1, satellite: satellite1, satelliteAngle: initialAngle1 } = createOrbitAndSatellite(7, Math.PI / 10000, Math.PI / 6, Math.PI / 10000);
  let satelliteAngle1 = initialAngle1; // 将初始角度赋给卫星的角度变量

  // 创建第二组轨道和卫星
  const { orbit: orbit2, satellite: satellite2, satelliteAngle: initialAngle2 } = createOrbitAndSatellite(10, Math.PI / 6, Math.PI / 4, Math.PI / 3);
  let satelliteAngle2 = initialAngle2; // 将初始角度赋给卫星的角度变量

  // 处理窗口大小变化
  window.addEventListener('resize', () => {
    renderer.setSize(window.innerWidth, window.innerHeight);
    camera.aspect = window.innerWidth / window.innerHeight;
    camera.updateProjectionMatrix();
  });

  // 使卫星沿轨道旋转的独立控制函数
  function updateSatellitePosition(satellite, satelliteAngle, orbitRadius, inclineAngleX, inclineAngleY) {
    satelliteAngle += 0.005; // Satellite rotation speed
    if (satelliteAngle > 2 * Math.PI) satelliteAngle -= 2 * Math.PI; // Ensure angle does not exceed 360 degrees

    // Calculate satellite's new position based on orbital radius and angles
    satellite.position.x = orbitRadius * Math.cos(satelliteAngle) * Math.cos(inclineAngleX); // Satellite X coordinate (inclined by Y axis)
    satellite.position.y = orbitRadius * Math.sin(satelliteAngle) * Math.cos(inclineAngleY); // Satellite Y coordinate (inclined by X axis)
    satellite.position.z = orbitRadius * Math.sin(satelliteAngle) * Math.sin(inclineAngleY) * Math.sin(inclineAngleX); // Satellite Z coordinate (inclined by both X and Y axes)

    return satelliteAngle; // Return updated angle
  }



  // 动画函数实现平滑的旋转效果
  let rotationSpeed = 0.001; // 控制地球旋转速度
  function animate() {
    requestAnimationFrame(animate);

    // 让地球持续旋转
    earth.rotation.y += rotationSpeed;

    // 更新卫星的位置（每个卫星都有自己的控制函数）
    satelliteAngle1 = updateSatellitePosition(satellite1, satelliteAngle1, 7, Math.PI / 2, Math.PI / 3); // 第一组卫星
    satelliteAngle2 = updateSatellitePosition(satellite2, satelliteAngle2, 10, Math.PI / 6, Math.PI / 4); // 第二组卫星

    // 更新控制器
    controls.update();

    // 渲染场景
    renderer.render(scene, camera);
  }

  animate();
</script>
</body>
</html>
