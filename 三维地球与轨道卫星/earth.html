<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>3D Earth and Satellite Orbits</title>
    <style>
        body { margin: 0; overflow: hidden; }
        canvas { display: block; }
    </style>
</head>
<body>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/build/three.min.js"></script>
<script src="https://cdn.jsdelivr.net/npm/three@0.128.0/examples/js/controls/OrbitControls.js"></script>
<script src="https://cdnjs.cloudflare.com/ajax/libs/satellite.js/4.0.0/satellite.min.js"></script>
<script>
    // Scene setup
    const scene = new THREE.Scene();
    const camera = new THREE.PerspectiveCamera(75, window.innerWidth / window.innerHeight, 0.1, 1000);
    const renderer = new THREE.WebGLRenderer();
    renderer.setSize(window.innerWidth, window.innerHeight);
    document.body.appendChild(renderer.domElement);

    // Create Earth sphere
    const earthGeometry = new THREE.SphereGeometry(6.4, 360, 180);
    const textureLoader = new THREE.TextureLoader();
    const earthTexture = textureLoader.load('https://api.allorigins.win/raw?url=https://www.solarsystemscope.com/textures/download/2k_earth_daymap.jpg');
    const earthMaterial = new THREE.MeshStandardMaterial({
        map: earthTexture,
        emissive: new THREE.Color(0xeeeeee),
        emissiveIntensity: 0.1
    });
    const earth = new THREE.Mesh(earthGeometry, earthMaterial);
    scene.add(earth);

    // Add lighting
    const pointLight = new THREE.PointLight(0xffffff, 1, 100);
    pointLight.position.set(10, 10, 10);
    scene.add(pointLight);

    const ambientLight = new THREE.AmbientLight(0x404040);
    scene.add(ambientLight);

    // Camera position
    camera.position.z = 20;

    // Add star background
    const starsGeometry = new THREE.SphereGeometry(50, 64, 64);
    const starsMaterial = new THREE.MeshBasicMaterial({
        color: 0x000000,
        side: THREE.BackSide,
        map: textureLoader.load('https://api.allorigins.win/raw?url=https://www.solarsystemscope.com/textures/download/2k_stars.jpg')
    });
    const stars = new THREE.Mesh(starsGeometry, starsMaterial);
    scene.add(stars);

    // Initialize OrbitControls
    const controls = new THREE.OrbitControls(camera, renderer.domElement);

    // Store satellites and their paths
    const satellites = [];
    const satellitePaths = [];

    async function fetchAndCreateSatellites() {
        try {
            const response = await fetch('https://www.celestrak.com/NORAD/elements/stations.txt'); // Replace with your TLE API URL
            const tleData = await response.text();
            const tleLines = tleData.split('\n').filter(line => line.trim() !== '');

            for (let i = 0; i < tleLines.length; i += 3) {
                const satelliteName = tleLines[i].trim();
                const tleLine1 = tleLines[i + 1].trim();
                const tleLine2 = tleLines[i + 2].trim();

                const satrec = satellite.twoline2satrec(tleLine1, tleLine2);
                const satelliteObject = createSatellite(0xff0000); // Each satellite has a red sphere
                satellites.push({ satrec, object: satelliteObject });

                const pathGeometry = new THREE.BufferGeometry();
                const pathMaterial = new THREE.LineBasicMaterial({ color: Math.random() * 0xffffff });
                const pathLine = new THREE.Line(pathGeometry, pathMaterial);
                satellitePaths.push({ pathLine, positions: [] });

                scene.add(pathLine);
            }

            updateSatellites();
        } catch (error) {
            console.error("Error fetching TLE data:", error);
        }
    }

    function createSatellite(color) {
        const satelliteGeometry = new THREE.SphereGeometry(0.1, 16, 16);
        const satelliteMaterial = new THREE.MeshStandardMaterial({ color });
        const satellite = new THREE.Mesh(satelliteGeometry, satelliteMaterial);
        scene.add(satellite);
        return satellite;
    }

    function updateSatellites() {
        const now = new Date();

        satellites.forEach((sat, index) => {
            const positionAndVelocity = satellite.propagate(sat.satrec, now);
            const position = positionAndVelocity.position;

            if (position) {
                const x = position.x / 1000;
                const y = position.y / 1000;
                const z = position.z / 1000;

                sat.object.position.set(x, y, z);

                // Update path
                const path = satellitePaths[index];
                path.positions.push(new THREE.Vector3(x, y, z));
                const pathPositions = [];
                path.positions.forEach(pos => {
                    pathPositions.push(pos.x, pos.y, pos.z);
                });

                path.pathLine.geometry.setAttribute('position', new THREE.Float32BufferAttribute(pathPositions, 3));
                path.pathLine.geometry.attributes.position.needsUpdate = true;
            }
        });

        setTimeout(updateSatellites, 1500);
    }

    // Handle window resizing
    window.addEventListener('resize', () => {
        renderer.setSize(window.innerWidth, window.innerHeight);
        camera.aspect = window.innerWidth / window.innerHeight;
        camera.updateProjectionMatrix();
    });

    // Animation loop
    function animate() {
        requestAnimationFrame(animate);
        controls.update();
        renderer.render(scene, camera);
    }

    fetchAndCreateSatellites();
    animate();
</script>
</body>
</html>
